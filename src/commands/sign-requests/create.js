'use strict';

const BoxCommand = require('../../box-command');
const { omit, mapKeys, snakeCase } = require('lodash');
const { Flags } = require('@oclif/core');
const BoxCLIError = require('../../cli-error');

const ALLOWED_SIGNER_ROLES = [
	'signer',
	'approver',
	'final_copy_reader'
];

class SignRequestsCreateCommand extends BoxCommand {
	async run() {
		const { flags } = await this.parse(SignRequestsCreateCommand);

		const {
			signer: signers,
			prefill_tag: prefillTags,
			document_preparation_needed: isDocumentPreparationNeeded,
			text_signatures_enabled: areTextSignaturesEnabled,
			reminders_enabled: areRemindersEnabled,
			template_id: templateId,
			...rest
		} = mapKeys(omit(flags, Object.keys(BoxCommand.flags)), (value, key) => snakeCase(key)
		);

		const signRequest = await this.client.signRequests.create({
			signers,
			prefill_tags: prefillTags,
			is_document_preparation_needed: isDocumentPreparationNeeded,
			are_text_signatures_enabled: areTextSignaturesEnabled,
			are_reminders_enabled: areRemindersEnabled,
			template_id: templateId,
			...rest,
		});

		await this.output(signRequest);
	}
}

SignRequestsCreateCommand.description = 'Create sign request';
SignRequestsCreateCommand.examples = ['box sign-requests:create --signer email=alice@example.com --source-files 12345 --parent-folder 23456  --prefill-tag id=1,value=Test'];
SignRequestsCreateCommand._endpoint = 'post_sign_requests';

SignRequestsCreateCommand.flags = {
	...BoxCommand.flags,
	signer: Flags.string({
		required: true,
		description:
			'A signer for the sign request. 35 is the max number of signers permitted. Can be added multiple times. ' +
			'Allowed (recommended) properties: email,role,is-in-person,order,embed-url-external-user-id,redirect-url,declined-redirect-url,group-id ' +
			'but snake case is also supported for: is_in_person,order,embed_url_external_user_id,redirect_url,declined_redirect_url,group_id',
		multiple: true,
		parse(input) {
			const signer = {
				role: 'signer',
			};

			for (const part of input.split(',')) {
				const [key, value] = part.split('=');

				switch (key) {
					case 'email':
						signer.email = value;
						break;

					case 'role':
						if (!ALLOWED_SIGNER_ROLES.includes(value)) {
							throw new BoxCLIError(
								`Invalid value for role property of signer: ${value}. Expecting one of: ${ALLOWED_SIGNER_ROLES.join(
									', '
								)}.`
							);
						}
						signer.role = value;
						break;

					case 'is-in-person':
					case 'is_in_person':
						if (value !== '0' && value !== '1') {
							throw new BoxCLIError(
								`Invalid value for is_in_person property of signer: ${value}. Expecting either 0 or 1.`
							);
						}
						signer.is_in_person = value === '1';
						break;

					case 'order':
						signer.order = value;
						break;

					case 'embed-url-external-user-id':
					case 'embed_url_external_user_id':
						signer.embed_url_external_user_id = value;
						break;

					case 'redirect_url':
					case 'redirect-url':
						signer.redirect_url = value;
						break;

					case 'declined-redirect-url':
					case 'declined_redirect_url':
						signer.declined_redirect_url = value;
						break;

					case 'signer-group-id':
					case 'signer_group_id':
					case 'group-id':
					case 'group_id':
						signer.signer_group_id = value;
						break;
					default:
						throw new BoxCLIError(`Unknown property for signer: ${key}`);
				}
			}

			return signer;
		},
	}),
	'source-files': Flags.string({
		description:
			'Comma separated list of files to create a signing document from. This is currently limited to 10 files, e.g. 12345',
		parse: (input) =>
			input.split(',').map((id) => ({
				type: 'file',
				id,
			})),
	}),
	'parent-folder': Flags.string({
		description:
			'The destination folder to place final, signed document and signing log',
		parse: (input) => ({
			type: 'folder',
			id: input,
		}),
	}),
	'document-preparation-needed': Flags.boolean({
		description:
			'Indicates if the sender should receive a `prepare_url` in the response to complete document preparation via UI.',
		allowNo: true,
	}),
	'text-signatures-enabled': Flags.boolean({
		description: 'Disables the usage of signatures generated by typing (text)',
		allowNo: true,
	}),
	'email-subject': Flags.string({
		description:
			'Subject of sign request email. This is cleaned by sign request. If this field is not passed, a default subject will be used.',
	}),
	'email-message': Flags.string({
		description:
			'Message to include in sign request email. The field is cleaned through sanitization of specific characters. However, some html tags are allowed. Links included in the message are also converted to hyperlinks in the email. The message may contain the following html tags including `a`, `abbr`, `acronym`, `b`, `blockquote`, `code`, `em`, `i`, `ul`, `li`, `ol`, and `strong`. Be aware that when the text to html ratio is too high, the email may end up in spam filters. Custom styles on these tags are not allowed. If this field is not passed, a default message will be used.',
	}),
	'reminders-enabled': Flags.boolean({
		description:
			'Reminds signers to sign a document on day 3, 8, 13 and 18. Reminders are only sent to outstanding signers.',
		allowNo: true,
	}),
	'prefill-tag': Flags.string({
		description:
			'Prefills a sign related tag in the content. Pass in a comma-separated dictionary of fields: id,text,checkbox,date. Can be added multiple times.',
		multiple: true,
		parse(input) {
			const prefillTag = {};

			for (const part of input.split(',')) {
				const [key, value] = part.split('=');

				switch (key) {
					case 'id':
						prefillTag.document_tag_id = value;
						break;

					case 'text':
						prefillTag.text_value = value;
						break;

					case 'checkbox':
						if (value !== '0' && value !== '1') {
							throw new BoxCLIError(
								`Invalid value for checkbox property of prefill-tag: ${value}. Expecting either 0 or 1.`
							);
						}
						prefillTag.checkbox_value = value === '1';
						break;

					case 'date':
						prefillTag.date_value = value;
						break;

					default:
						throw new BoxCLIError(`Unknown property for prefill-tag: ${key}`);
				}
			}

			return prefillTag;
		},
	}),
	'days-valid': Flags.integer({
		description:
			'Number of days after which this request will automatically expire if not completed',
	}),
	'external-id': Flags.string({
		description:
			'This can be used to reference an ID in an external system that the sign request is related to.',
	}),
	'redirect-url': Flags.string({
		description:
			'The URL that a signer will be redirected to after signing a document. Defining this URL overrides the default redirect URL for all signers. If no declined redirect URL is specified, this URL will be used for decline actions as well.',
	}),
	'declined-redirect-url': Flags.string({
		description:
			'The URL that a signer will be redirected to after declining to sign a document. Defining this URL overrides the default redirect URL for all signers.',
	}),
	'template-id': Flags.string({
		description:
			'When a signature request is created from a template this field will indicate the id of that template.',
	}),
};

module.exports = SignRequestsCreateCommand;
